\documentclass[]{article}
\usepackage{algpseudocode}

\usepackage{algorithm}
\usepackage{float}% 
%opening
\title{Notes}
\author{Andrin Rehmann}

\begin{document}

\maketitle

\section{Datapoints of supercomputers}

\begin{center}
	\begin{tabular}{ c c c }
		& Piz Daint HYBRID \cite{piz_daint} & Summit \\ 
		\hline
		Number of Nodes & 5704 & 4608\\
		CPU Mem. Cap. & 64 GB & 256 GB $\times$ 2  \\   
		CPU Model & Intel Xeon E5-2690 v3 & IBM POWER9 $\times$ 2 \\
		CPU Mem. Bandwidth  & 68 GB/s & 170 GB/s\\
		GPU Model & NVIDIA Tesla P100 & NVIDIA Volta V100s $\times$ 6 \\
		GPU Mem. Cap. & 16 GB & 16 GB $\times$ 6\\
		GPU Mem. Bandwidth & 732 GB/s & 900 GB/s \\
		Interconnect Bandwidth & 32 GB/s & 50 GB/s \\
	\end{tabular}
\end{center}

\subsection{Terminology}

\begin{enumerate}
	\item Memory Bandwidth: read / write speed of semiconductor memory
	\item 

\end{enumerate}

\section{Analysis of GPU ORB building}

\begin{itemize}
	\item 
	One particle requires 32 bytes of storage. Where the XYZ coordinates require $4\times3 = 12$ bytes of storage, the rest is used for additional information.
	
	\item
	A single iteration of the binary cut algorithm requires $32 \times N$ operations.
	
	\item 
	All particles are assumed to be stored in the CPU memory initially.
	
	\item
	We perform the analysis on one billion particles. This means we need 32 GB storage for all the particles and 12 GB for only the XYZ positions.
	
	\item
	We do not consider calculation times as memory access times far outweigh them. The operations are simple comparison operations which require only very little cycles on the chip. 
\end{itemize}


\subsection{Piz Daint} 
When executing the algorithm on the CPU, for a single iteration of the binary cut algorithm we perform a scan over an axis of all particle positions. This translates to $10^9 \times 4 bytes = 4 GB$.
On the CPU this results in a memory access time of 
\begin{center}
	$32 \times \frac{ 4 GB}{68 GB/s} = 1.8 s$ 
\end{center}

If we do the same on the GPU we get an access time of:
\begin{center}
	$32 \times \frac{4 GB}{732 GB/s} + \frac{4 GB}{32 GB/s} = 0.3 s$ 
\end{center}

This results in a theoretical speedup of:

\begin{center}
	$\frac{1.8}{0.3} = 6$
\end{center}

Where the first part are the 32 iterations of the memory sweep and the second part are the transfer times from CPU to GPU. We only need to transfer back a single number, which is then used to termine the next split position. Thus transfer times from the GPU to CPU are negligible. It is clear that the transfer times from the CPU to the GPU dominate the runtime.

Let us now consider an alternative way of computing binary cuts. We will build part of the tree on the GPU itself. We have a shared memory size of 64 KB. Since storing the information about the tree requires only very little storage, we are not limited by memory and can perform 32 cuts on the GPU. Note that in this case we need to load all three coordinates to the GPU. We omit the domain data transfer from the GPU to the CPU as it can be stored in very little memory. 

\begin{center}
	$32 \times 32 \times \frac{ 4 GB}{68 GB/s} = 60.2 s$ 
\end{center}

\begin{center}
	$32 \times 32 \times \frac{4 GB}{732 GB/s} + \frac{12 GB}{32 GB/s} + \frac{4 GB}{32 GB/s} = 6 s$ 
\end{center}

\begin{center}
	$\frac{60.2}{6} = 10$ 
\end{center}
 
\subsection{ORB Algorithm}
The general idea of the ORB algorithm is to split a $k$ dimensional domain containing $N$ particles into subdomains. Each subdomain contains an equal number of particles, which can also be relaxed for accommodate odd particle counts and increase performance. 

We assume positions are stored as a 32 bit precision float which is reasonable for astrophysical calculations. 
\begin{algorithm}[H]
	\caption{The Orthogonal Recursive Bisection Algorithm in 3D}\label{euclid}
	\begin{algorithmic}[1]
		\Procedure{orb}{$cornerA, cornerB ,particles$}
		\State $size = cornerB - cornerA$
		\State $index = maxIndex(size.x, size.y, size.z)$ \Comment{Get index of max size}
	
		\State $nLeft = 0$
		\State $left = cornerA[index]$
		\State $right = cornerB[index]$
		
		\State $split = (right - left) / 2 + left $ \Comment{Initial guess}
		\While{$abs(nLeft - particles.len/2) > 1 $}
		\State $split = (right - left) / 2 + left $
		\State $nLeft\gets sum(particles < split)$
		\If{$nLeft <= particles.len / 2$}
			\State $left = split$
		\Else 
			\State $right = split$
		\EndIf
		\EndWhile\label{euclidendwhile}
		
		\State \Call {orb}{cornerA, cornerB}
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

The reshuffle procedure takes the array of particles and rearanges the elements such that all element left of the split are on the one side, and the others are on the other side.

\bibliographystyle{plain}
\bibliography{reference}

\end{document}
